---
layout: post
title: "Analysis of the OpenSSL random API"
subtitle: "or: how not to design an API"
category: 
published: false
tags: [network, security, openssl, ssl]
---
OpenSSL provides two functions for obtaining a sequence of random octets:
`RAND_bytes` and `RAND_pseudo_bytes`.  `RAND_bytes` guarantees to provide high
quality random material; `RAND_pseudo_bytes` does not, but instead tells
the caller if the returned material is low quality.

Their function prototypes are:

>     int RAND_bytes(unsigned char *buf, int num);
>     int RAND_pseudo_bytes(unsigned char *buf, int num);

These are backed by a configurable set of providers -- 'RAND methods'.  There are methods
for CPU hardware RNGs, hardware security modules, and so on.

# First stop: documentation
Excerpts from `RAND_bytes`(3SSL):

> ## Description
> `RAND_bytes()` puts num cryptographically strong pseudo-random bytes into buf.
> An error occurs if the PRNG has not been seeded with enough randomness to
> ensure an unpredictable byte sequence.
> 
> `RAND_pseudo_bytes()` puts num pseudo-random bytes into buf.  Pseudo-random byte
> sequences generated by `RAND_pseudo_bytes()` will be unique if they are of
> sufficient length, but are not necessarily
> unpredictable. They can be used for non-cryptographic purposes and for certain purposes in cryptographic
> protocols, but usually not for key generation etc.
>
> ## Return values
> `RAND_bytes()` returns `1` on success, `0` otherwise. The error code can be obtained by `ERR_get_error(3)`.
> `RAND_pseudo_bytes()` returns `1` if the bytes generated are cryptographically strong, `0` otherwise. Both
> functions return `-1` if they are not supported by the current RAND method.

The return values and state of the buffer on return are important and bear repeating:

`RAND_bytes`:

- `1`: success (buffer written)
- `0`: error (buffer indeterminate)
- `-1`: not supported (buffer indeterminate)
  
`RAND_pseudo_bytes`:

- `1`: success - high quality (buffer written)
- `0`: success - low quality (buffer written)
- `-1`: not supported (buffer indeterminate)

# Incorrect error handling in the wild
The scheme for `RAND_bytes`'s return value is a bad idea, because it makes
the natural way to write a call incorrect:

>     if (!RAND_bytes(...))
>         /* handle error ... */

That this is incorrect didn't stop people calling it that way. [Debian code search][debiancs]
gives us some culprits, including OpenSSL (yes, really: OpenSSL calls its own API incorrectly),
Ruby, net-snmp, ZNC, DACS, and dnsval/dnssec-tools[^bugs].  [Github code search][githubcs]
gives 1456 results for the same query, but let's assume there's nothing of importance on github :)
Android also [called this incorrectly][android] in versions before 4.4.

These are of particular concern where other modules existing in the same process space, and
could plausibly install a RAND method which doesn't support `RAND_bytes` -- like language
runtimes and libraries.

[debiancs]: http://codesearch.debian.net/search?prev=&q=%21%5Cs%2A`RAND_bytes`
[githubcs]: https://github.com/search?p=7&q=%21`RAND_bytes`&ref=searchresults&type=Code
[android]: https://android.googlesource.com/platform/libcore/+/0f116e1
[^bugs]: Note: I haven't verified that each one of these is actually a bug, or in an important (or even used!) bit of code.

# Evaluation of all RAND methods
The meat of this work: I tracked down all the `RAND_METHOD` definitions I could find, in OpenSSL
and elsewhere.

## OpenSSL

- `engines/e_aep.c`: 
  * `RAND_bytes` same function as `RAND_pseudo_bytes`.
  * Returns `0` on error, and adds an error.
  * Can fail without altering buffer.
- `engines/e_4758cca.c`:
  * `RAND_bytes` same function as `RAND_pseudo_bytes`.
  * Returns 0 on error, does not add an error.
  * Can fail without altering buffer.
- `engines/e_padlock.c`: **Disabled code.**
  * `RAND_bytes` same function as `RAND_pseudo_bytes`.
  * Returns 0 on error, does not add an error.
  * Can fail without altering buffer.
- `engines/e_chil.c`:
  * `RAND_bytes` same function as `RAND_pseudo_bytes`.
  * Returns 0 on error, and adds an error.
  * Fails without altering buffer.
- `engines/e_ubsec.c`: **Disabled code.**
  * `RAND_bytes` same function as `RAND_pseudo_bytes`.
  * Passes through to `RAND_SSLeay` on error,
    returning whatever `RAND_SSLeay()->bytes` said.
    But also adds an error even if this succeeds.
  * Logical error in one error case, meaning
    **you can get a partially filled output buffer
    and a success result (!!!!)**.  It's probably
    for the best that this is disabled.  Delete
    unused code?
- `engines/e_cswift.c`:
  * `RAND_bytes` same function as `RAND_pseudo_bytes`.
  * Returns 0 on error, and adds an error.
  * Can fail without altering buffer.
- `engines/e_sureware.c`:
  * `RAND_bytes` same function as `RAND_pseudo_bytes`.
  * Returns 0 on error, and adds an error.
  * Can fail without altering buffer.
- `demos/engines/cluster_labs/hw_cluster_labs.c`:
  * `RAND_bytes` same function as `RAND_pseudo_bytes`.
  * Cannot tell error behaviour.
- `demos/engines/ibmca/hw_ibmca.c`:
  * `RAND_bytes` same function as `RAND_pseudo_bytes`.
  * Returns 0 on error, and adds an error.
  * Can fail without altering buffer.
- `demos/engines/zencod/hw_zencod.c`:
  * `RAND_bytes` same function as `RAND_pseudo_bytes`.
  * Returns 0 on error, and adds an error.
  * Can fail without altering buffer.
  * Has a macro named `CHEESE`.
- `crypto/engine/eng_rdrand.c`:
  * `RAND_bytes` same function as `RAND_pseudo_bytes`.
  * Returns 0 on error, does not add an error.
  * Can fail without altering buffer.
- `crypto/rand/md_rand.c`:
  * `RAND_bytes` differs from `RAND_pseudo_bytes`.
  * Returns 0 on error, and adds an error.
  * Can fail without altering buffer.
  * `RAND_pseudo_bytes` can return 0 both with
    and without writing to buffer.
- `fips/rand/fips_drbg_rand.c`:
  * `RAND_bytes` same function as `RAND_pseudo_bytes`, except in
    error behaviour.
  * `RAND_bytes` returns 0 on error, and adds an error.
  * `RAND_pseudo_bytes` returns -1 on error, and
    adds an error. It never returns 0.
- `fips/rand/fips_rand.c`:
  * `RAND_bytes` same function as `RAND_pseudo_bytes`.
  * Returns 0 on error, and adds an error.
  * Can fail without altering buffer.

## In bind 9 (`bin/pkcs11/openssl-1.01c-patch`)
* `RAND_bytes` same function as `RAND_pseudo_bytes`
* Returns 0 on error, and adds an error.
* Can fail without altering buffer.

## Heimdal
- `lib/hcrypto/rand-fortuna.c`:
  * `RAND_bytes` same function as `RAND_pseudo_bytes`
  * Returns 0 on error, does not add an error.
  * Can fail without altering buffer.
- `lib/hcrypto/rand-egd.c`:
  * `RAND_bytes` same function as `RAND_pseudo_bytes`
  * Returns 0 on error, does not add an error.
  * Can fail without altering buffer.
- `lib/hcrypto/rand-timer.c`:
  * `RAND_bytes` same function as `RAND_pseudo_bytes`
  * Returns 0 on error, does not add an error.
  * UB here which means it returns an undefined
    value on platforms without `setitimer(2)` if `fork(2)`
    fails.
  * Can fail without altering buffer.
- lib/hcrypto/rand-unix.c:
  * `RAND_bytes` same function as `RAND_pseudo_bytes`
  * Returns 0 on error, does not add an error.
  * Can fail without altering buffer.
- lib/hcrypto/rand-w32.c:
  * `RAND_bytes` same function as `RAND_pseudo_bytes`
  * Returns 0 on error, does not add an error.
  * Can fail without altering buffer.
  
# Round up
That's a big list.  The main point to note is:

**All `RAND_pseudo_bytes` implementations are broken in their error cases**,
except one (`fips/rand/fips_drbg_rand.c`) which misses out by returning
an undocumented error code.  This is frighteningly dangerous error behaviour.

Here's a test program:

{% highlight c++ linenos %}
#include <stdio.h>
#include <openssl/rand.h>

int main(void)
{
    unsigned char buf[28] = { 0 };
    int err = RAND_pseudo_bytes(buf, sizeof buf);

    if (err == 1)
        printf("strong randomness: ");
    else if (err == 0)
        printf("weak randomness: ");
    else {
        printf("RAND_pseudo_bytes failed: %d\n", err);
        return 1;
    }

    for (size_t i = 0; i < sizeof buf; i++)
        printf("%02x", buf[i]);
    printf("\n");
    return 0;
}
{% endhighlight %}

This performs as you'd expect using the default `RAND_METHOD` (`crypto/rand/md_rand.c`):

{% highlight sh %}
$ ./simple-randtest 
strong randomness: 38799d450b619ccaa05e0265a7b35c293aec6f4ef314665e75c57871
$
{% endhighlight %}

However, if we arrange for a certain `malloc(3)` invocation to fail, we get:

{% highlight sh %}
$ MALLOC_FAILS=57 LD_PRELOAD=./brokenmalloc.so ./simple-randtest 
failed malloc 57 by request
weak randomness: 00000000000000000000000000000000000000000000000000000000
$ 
{% endhighlight %}

That's really not healthy.

# Implications
A laundry list:

* `BN_pseudo_rand` can return bits of heap converted to a bignum if `RAND_pseudo_bytes` fails for any reason.
* The same bug spreads to `BN_pseudo_rand_range`, `BN_generate_prime_ex` (when choosing the Rabin-Miller witness), etc.
